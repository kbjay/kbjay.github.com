<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>docker | kb_jay的开发站台</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="入门虚拟化技术主要目的：可以在一个物理设备上做到环境隔离 主机级别虚拟化两种类型  在裸（物理）机上装hostOs，之后在hostOs上hypervisor（eg：vmware），之后在hypervisor上装各种系统 在裸（物理）机上直接装hypervisor，之后在hypervisor上装各种系统   假设需要运行一个web服务，为此我们必须先安装hypervisor，再安装系统，之后在系统上">
<meta property="og:type" content="article">
<meta property="og:title" content="docker">
<meta property="og:url" content="http://yoursite.com/2020/03/04/docker/index.html">
<meta property="og:site_name" content="kb_jay的开发站台">
<meta property="og:description" content="入门虚拟化技术主要目的：可以在一个物理设备上做到环境隔离 主机级别虚拟化两种类型  在裸（物理）机上装hostOs，之后在hostOs上hypervisor（eg：vmware），之后在hypervisor上装各种系统 在裸（物理）机上直接装hypervisor，之后在hypervisor上装各种系统   假设需要运行一个web服务，为此我们必须先安装hypervisor，再安装系统，之后在系统上">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583476452667&di=a41943c55bea90dd6eaa3ebbeec33adf&imgtype=jpg&src=http%3A%2F%2Fimg2.imgtn.bdimg.com%2Fit%2Fu%3D623266907%2C3100268360%26fm%3D214%26gp%3D0.jpg">
<meta property="og:image" content="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583472581256&di=b4ff5c940beec76f50ad74ca4290a0bc&imgtype=jpg&src=http%3A%2F%2Fimg.dongcoder.com%2Fup%2Finfo%2F201807%2F20180715132007371540.png">
<meta property="og:image" content="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=113669502,2763591295&fm=26&gp=0.jpg">
<meta property="og:image" content="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1584465867957&di=33802fb735f90368ba860b1b596ec3f2&imgtype=0&src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-e67ade9faeaa9b8c1dbbd146e6d5444f_b.jpg">
<meta property="og:updated_time" content="2020-06-04T10:01:52.280Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="docker">
<meta name="twitter:description" content="入门虚拟化技术主要目的：可以在一个物理设备上做到环境隔离 主机级别虚拟化两种类型  在裸（物理）机上装hostOs，之后在hostOs上hypervisor（eg：vmware），之后在hypervisor上装各种系统 在裸（物理）机上直接装hypervisor，之后在hypervisor上装各种系统   假设需要运行一个web服务，为此我们必须先安装hypervisor，再安装系统，之后在系统上">
<meta name="twitter:image" content="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1583476452667&di=a41943c55bea90dd6eaa3ebbeec33adf&imgtype=jpg&src=http%3A%2F%2Fimg2.imgtn.bdimg.com%2Fit%2Fu%3D623266907%2C3100268360%26fm%3D214%26gp%3D0.jpg">
  
    <link rel="alternate" href="/atom.xml" title="kb_jay的开发站台" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">kb_jay的开发站台</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-docker" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/04/docker/" class="article-date">
  <time datetime="2020-03-04T11:49:42.000Z" itemprop="datePublished">2020-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      docker
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h4><p>主要目的：可以在一个物理设备上做到环境<em>隔离</em></p>
<h5 id="主机级别虚拟化"><a href="#主机级别虚拟化" class="headerlink" title="主机级别虚拟化"></a>主机级别虚拟化</h5><p>两种类型</p>
<ul>
<li>在裸（物理）机上装hostOs，之后在hostOs上hypervisor（eg：vmware），之后在hypervisor上装各种系统</li>
<li>在裸（物理）机上直接装hypervisor，之后在hypervisor上装各种系统</li>
</ul>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1583476452667&amp;di=a41943c55bea90dd6eaa3ebbeec33adf&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg2.imgtn.bdimg.com%2Fit%2Fu%3D623266907%2C3100268360%26fm%3D214%26gp%3D0.jpg" alt="img"></p>
<p>假设需要运行一个web服务，为此我们必须先安装hypervisor，再安装系统，之后在系统上安装nginx或者tomcat；</p>
<p>如果是第一种类型，使用物理资源还需要经过两个内核的调度，这样开销是比较大的。</p>
<h5 id="容器级别虚拟化"><a href="#容器级别虚拟化" class="headerlink" title="容器级别虚拟化"></a>容器级别虚拟化</h5><p>linux分为内核跟用户空间，linux内核有两个功能：</p>
<ul>
<li>namespace</li>
<li>cgroup</li>
</ul>
<p>通过这两个功能，linux可以做到对用户空间的隔离。这些隔离的用户空间就是容器。</p>
<p>每一个虚拟机都有自己的ip，域名，文件系统等等，一个主机有的它基本都有。</p>
<p>容器也需要有独立的：</p>
<ul>
<li>主机名：域名</li>
<li>文件系统</li>
<li>进程通信ipc</li>
<li>进程id（pid）</li>
<li>用户组</li>
<li>net（ip地址，端口，等）</li>
</ul>
<p>这个就是通过命名空间（namespace）实现的；自己理解可以类比写代码时的namespace（相同的类名在不同的namespace下是隔离的）</p>
<p>然而不同namespace之间物理资源（更多是硬件资源，cpu，内存等）还是相互竞争的。仍然需要管理每个container可以使用的资源。cgroups 实现了对资源的配额和度量，通过它我们可以实现资源的隔离分配。</p>
<h4 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h4><p>容器级别虚拟化相对主机级别虚拟化</p>
<ul>
<li>开销小，因为直接运行在宿主机上</li>
<li>隔离性上差点意思</li>
</ul>
<p>这两种虚拟化技术都有一个问题：迁移性。</p>
<p>docker利用镜像跟仓库很好的解决了这个问题。</p>
<p>有了docker之后我们可以一次编写到处运行，只要安装了docker，这一点跟jvm挺像的。</p>
<p>最大的优点：分发部署</p>
<h3 id="Docker基本用法"><a href="#Docker基本用法" class="headerlink" title="Docker基本用法"></a>Docker基本用法</h3><h4 id="docker架构图"><a href="#docker架构图" class="headerlink" title="docker架构图"></a>docker架构图</h4><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1583472581256&amp;di=b4ff5c940beec76f50ad74ca4290a0bc&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg.dongcoder.com%2Fup%2Finfo%2F201807%2F20180715132007371540.png" alt="img"></p>
<p>c/s架构，使用远程api的方式管理跟创建Docker容器。</p>
<ol>
<li><p>dockerClient</p>
<p>类似postman，可以发送get，post，put等等各种请求给host，通过api的方式增删改查image跟container</p>
</li>
<li><p>dockerHost</p>
<ul>
<li>dockerDeamon：用来监听套接字，一般在宿主主机的后台运行，等待接受客户端的请求（docker命令），类比服务端程序。</li>
<li>image： 用来生成容器的<ul>
<li>只读的</li>
<li>分层构建的（可以通过dockerFile理解）,可以根据自己的需求在已有得镜像的基础上随意扩展</li>
<li>静态的</li>
</ul>
</li>
<li>container：隔离的用户空间，一个独立于主机的隔离的进程，由image创建</li>
</ul>
</li>
<li><p>Registry</p>
<p>主要功能是作为repository存放image，docker官方提供了dockerhub，但是服务器在国外，访问比较慢，在国内也提供了，但是也不快。可以使用阿里或者科大或者清华的镜像仓库。个人配置的是阿里的，体验挺好的（需要注册一个阿里账户，之后会分配一个地址）。</p>
<p>阿里镜像加速：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p>
</li>
</ol>
<p>image跟container的关系：类似程序跟进程的关系，类似class跟实体的关系</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>在终端输入 docker container create –name n3 nginx，</p>
<ol>
<li>host的deamon收到请求（http的方式）</li>
<li>在本地检查是否有nginx镜像</li>
<li>如果有，那么根据镜像创建n3容器</li>
<li>如果么有，那么发请求到（https）registry中拉去nginx镜像到本地，之后在本地创建n3容器</li>
</ol>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="docker-1"><a href="#docker-1" class="headerlink" title="docker"></a>docker</h5><ul>
<li>docker verison</li>
<li>docker info  （镜像加速配置完之后可以通过它来查看是否配置成功了）</li>
<li>docker search  镜像名  ：dockerhub上查找镜像</li>
<li>docker inspect 容器名或者镜像名      ：  查看容器或者镜像的详细信息（可以查看容器的ip地址，挂载信息等等）</li>
<li>docker exec -it 容器名 /bin/bash ：  进入容器终端</li>
<li>docker logs 容器名  </li>
<li>docker cp 容器名:容器文件或文件夹  宿主机文件或文件夹   ：将容器中的文件或文件夹复制出来</li>
<li>docker tag  给镜像打标签</li>
<li>docker commit  通过容器创建镜像</li>
</ul>
<h5 id="image"><a href="#image" class="headerlink" title="image"></a>image</h5><ul>
<li>docker image pull 镜像名:tag     ： 拉取镜像，tag可以缺省</li>
<li>docker image ls   : 查看所有的镜像</li>
<li>docker image rm 镜像名  ：删除镜像</li>
</ul>
<h5 id="container"><a href="#container" class="headerlink" title="container"></a>container</h5><ul>
<li><p>docker container ls -a         : 查看所有容器</p>
</li>
<li><p>docker container ls -s         : 可以查看容器的size</p>
</li>
<li><p>docker container create –name n1 nginx  :创建nginx容器n1</p>
</li>
<li><p>docker container start n1    ：启动n1</p>
</li>
<li><p>docker container stop xxx  ：停止容器</p>
</li>
<li><p>docker container rm xxx  ：删除stop的容器</p>
</li>
<li><p>docker container run -it –name n2 nginx  /bin/bash   :创建并启动nginx容器n2，并进入容器终端</p>
</li>
<li><p>doker container  run -it –name xxx  –rm   -v   xxx1:xxx2  镜像名 /bin/bash </p>
<ul>
<li>it：可以交互的终端</li>
<li>rm：运行完自动删除</li>
<li>d：  运行在后台</li>
<li>name xxx： 容器名</li>
<li>v : 文件挂载    主机的xxx1挂载到容器的xxx2</li>
</ul>
</li>
</ul>
<h5 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h5><ul>
<li>Netstat -tnl  查看监听的端口</li>
</ul>
<h3 id="Docker-镜像管理基础"><a href="#Docker-镜像管理基础" class="headerlink" title="Docker 镜像管理基础"></a>Docker 镜像管理基础</h3><p>镜像就是把业务代码，可运行环境进行整体的打包。</p>
<p>镜像包含了启动容器需要的文件系统跟其他内容，因此，镜像用来创建并启动容器。</p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/70424048" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/70424048</a></p>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ul>
<li>我们基于同一个镜像（ubuntu 18.4）启动了两个容器，会占用两倍磁盘空间吗？</li>
<li>我们在容器内修改或者新建了某个文件，要修改原镜像吗？</li>
<li>我们基于某镜像（ubuntu 18.04）新建一个镜像（myubuntu），需要将原镜像文件全部拷贝到新镜像中吗？</li>
</ul>
<p>首先，让我们尝试思考下，如果我们去做，该如何高效的解决这些问题？</p>
<ul>
<li>问题 1，只要将同一个镜像文件加载到内存不同位置就行了，没必要在磁盘上存储多份，可以节省大量存储空间。</li>
<li>问题 2，我们可以参考 Linux 内核管理内存的 <em>Copy-On-Write 策略，也即读时大家共用一份文件，如果需要修改再复制一份进行修改，而大部分文件是其实不会修改的，这样可以最大限度节省空间，提升性能。</em></li>
<li>问题 3，我们可以将镜像文件分为多个独立的层，然后新镜像文件只要引用基础镜像文件就可以了，这样可以节省大量空间。至于修改基础镜像文件的情况，参考问题 2 </li>
</ul>
<h4 id="镜像分层"><a href="#镜像分层" class="headerlink" title="镜像分层"></a>镜像分层</h4><p><img src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=113669502,2763591295&amp;fm=26&amp;gp=0.jpg" alt="img"></p>
<ol>
<li>镜像分层，除了最上层的容器层是可读写的，其他层都是只读的。如果容器层需要读写其他层的数据，需要用到copy-on-write技术</li>
<li>只读层是可以共享的</li>
<li>每个容器都有自己的读写层，容器被删之后读写层也会被删除。如果想要持久化数据，可以使用docker挂载（volume）：比如log日志</li>
<li>执行docker ps -s（或者docker container ls -s）可以看到容器最后一列有个size（2B (virtual 127MB)），这里的2B就是读写层的大小，127M是读写层加只读层的大小。</li>
</ol>
<h5 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h5><p>docker可以实现分层依赖的就是unionFs，所谓 UnionFS 就是把不同物理位置的目录合并到同一个目录中。对应docker，就是把下层的文件“合并”到上层，如果在上层想要修改下层的文件，需要先把下层文件copy到上层，之后再修改，但是下层的文件是不变的。</p>
<p>14年的时候linux内核中合并了overlayFs，也是现在docker使用的存储方案，执行docker info可以看到。</p>
<p><a href="https://zhuanlan.zhihu.com/p/70424048" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/70424048</a> 这篇文章中使用mount命令在ubuntu中模拟了docker的分层。</p>
<h4 id="镜像构建分发"><a href="#镜像构建分发" class="headerlink" title="镜像构建分发"></a>镜像构建分发</h4><h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><ol>
<li><p>通过容器构建</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -p m1 kj/mysql:v1</span><br></pre></td></tr></table></figure>
<ul>
<li>-p   暂停容器</li>
<li>m1  容器名</li>
<li>kj/mysql  镜像仓库名</li>
<li>v1   镜像版本</li>
</ul>
</li>
<li><p>通过dockerfile构建</p>
<ul>
<li>可以跟github，docker仓库（阿里云或者dockerhub）联动</li>
</ul>
</li>
</ol>
<ul>
<li>上传dockerFile到github，docker仓库检测到dockerfile的变化，会去github上拉代码然后build好镜像<ul>
<li>底层也是基于容器构建的，只不过是docker帮我们新建了一个容器，dockerfile实际是在这个容器里面执行的</li>
</ul>
</li>
</ul>
<h5 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h5><ol>
<li><p>上传到仓库分发</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker login </span><br><span class="line">docker push</span><br></pre></td></tr></table></figure>
<ul>
<li>Dockerhub镜像的仓库名必须跟hub上的一致</li>
<li>阿里云</li>
</ul>
</li>
<li><p>本地打包分发</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker save</span><br><span class="line">docker load</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="容器虚拟网络"><a href="#容器虚拟网络" class="headerlink" title="容器虚拟网络"></a>容器虚拟网络</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>Linux内核支持二层以及三层设备的虚拟化。</p>
<ol>
<li><p>虚拟网卡</p>
<ul>
<li><p>linux内核支持虚拟网卡的创建（ip命令）</p>
</li>
<li><p>每一个虚拟网卡是成对出现的，可以模拟成一根网线（下图中的eth0跟veth就是虚拟网卡的两端）</p>
</li>
</ul>
<p>作用：连接虚拟网桥跟容器</p>
</li>
<li><p>虚拟网桥（交换机）</p>
<ul>
<li><p>Docker0</p>
</li>
<li><p>ip，mac映射</p>
</li>
<li><p>linux内核也支持虚拟交换机的创建（brctl 命令）</p>
</li>
<li><p>通过交换机，同一个网段不同的容器可以通信</p>
</li>
</ul>
<p>作用：将主机以及所有的容器放在同一个局域网内</p>
</li>
<li><p>nat</p>
<p>网络地址转化</p>
<p>作用</p>
<ul>
<li><p>将容器的私有地址转化为物理网卡的地址（snat）</p>
</li>
<li><p>将物理网卡的地址转化为容器的地址（dnat）</p>
</li>
</ul>
</li>
</ol>
<h4 id="docker的四种网络模式"><a href="#docker的四种网络模式" class="headerlink" title="docker的四种网络模式"></a>docker的四种网络模式</h4><h5 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h5><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p>
<p>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。</p>
<p>bridge模式是docker的默认网络模式，不写–net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用iptables -t nat -vnL查看</p>
<p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1584465867957&amp;di=33802fb735f90368ba860b1b596ec3f2&amp;imgtype=0&amp;src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-e67ade9faeaa9b8c1dbbd146e6d5444f_b.jpg" alt="img"></p>
<h5 id="host"><a href="#host" class="headerlink" title="host"></a>host</h5><p>如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<h5 id="container-1"><a href="#container-1" class="headerlink" title="container"></a>container</h5><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p>
<h5 id="none"><a href="#none" class="headerlink" title="none"></a>none</h5><p>使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p>
<h4 id="bridge模型验证"><a href="#bridge模型验证" class="headerlink" title="bridge模型验证"></a>bridge模型验证</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze4qtfwa4w5rqbr2e83Z ~]<span class="comment"># ifconfig</span></span><br><span class="line"></span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line"></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line"></span><br><span class="line">veth4c07805: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line"></span><br><span class="line">veth718f748: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line"></span><br><span class="line">vethce1977e: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line"></span><br><span class="line">vethf87afa7: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br></pre></td></tr></table></figure>
<p>docker0就是虚拟网桥</p>
<p>vethxxx是虚拟网卡的一端，都是连接在docker0上的，使用brctl验证如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze4qtfwa4w5rqbr2e83Z ~]<span class="comment"># yum -y install bridge-utils</span></span><br><span class="line"></span><br><span class="line">[root@iZ2ze4qtfwa4w5rqbr2e83Z ~]<span class="comment"># brctl show</span></span><br><span class="line">bridge name			bridge id					STP enabled			interfaces</span><br><span class="line">docker0					8000.0242e24e01a3	no							veth4c07805</span><br><span class="line">																									veth718f748</span><br><span class="line">																									vethce1977e</span><br><span class="line">																									vethf87afa7</span><br></pre></td></tr></table></figure>
<p>验证网卡连接：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze4qtfwa4w5rqbr2e83Z ~]<span class="comment"># ip link show</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group </span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DEFAULT group </span><br><span class="line">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT </span><br><span class="line">5: vethce1977e@if4: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 </span><br><span class="line">9: vethf87afa7@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 </span><br><span class="line">17: veth718f748@if16: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master </span><br><span class="line">19: veth4c07805@if18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master</span><br></pre></td></tr></table></figure>
<p>5,9,17,19是4个网卡，以“vethce1977e@if4”为例，vethce1977e是连接在docker0上的，if4是放在容器上的。</p>
<p>进入容器查看网卡：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wangzeqi@wangzeqideMacBook-Pro ~ % docker run -it --name b1 busybox /bin/sh</span><br><span class="line">/ <span class="comment"># ifconfig</span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:03</span><br><span class="line">          inet addr:172.17.0.3  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line"></span><br><span class="line">/ <span class="comment"># ping 172.17.0.1</span></span><br><span class="line">PING 172.17.0.1 (172.17.0.1): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.1: seq=0 ttl=64 time=2.169 ms</span><br></pre></td></tr></table></figure>
<p>eth0就是虚拟网卡的另一端，ping 虚拟网桥docker0可以ping通。</p>
<p>nat：查看iptables规则</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ2ze4qtfwa4w5rqbr2e83Z ~]<span class="comment"># iptables -t nat -vnL</span></span><br></pre></td></tr></table></figure>
<p>所有收到的源地址为172.18.0.0/16（除了docker0）目标地址为任意地址的请求，都做snat（局域网内部私有地址转化为主机物理网卡的地址） tip：  MASQUERADE的翻译是化妆，非常形象</p>
<p>主机端口通过dnat转发到容器端口</p>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/yy-cxd/p/6553624.html" target="_blank" rel="noopener">https://www.cnblogs.com/yy-cxd/p/6553624.html</a></p>
<p><a href="https://blog.csdn.net/nia305/article/details/82775384" target="_blank" rel="noopener">https://blog.csdn.net/nia305/article/details/82775384</a></p>
<h4 id="tip-1"><a href="#tip-1" class="headerlink" title="tip"></a>tip</h4><p>Q：Docker For Mac没有docker0网桥</p>
<p>在使用Docker时，要注意平台之间实现的差异性，如Docker For Mac的实现和标准Docker规范有区别，Docker For Mac的Docker Daemon是运行于虚拟机(xhyve)中的, 而不是像Linux上那样作为进程运行于宿主机，因此Docker For Mac没有docker0网桥，不能实现host网络模式，host模式会使Container复用Daemon的网络栈(在xhyve虚拟机中)，而不是与Host主机网络栈，这样虽然其它容器仍然可通过xhyve网络栈进行交互，但却不是用的Host上的端口(在Host上无法访问)。bridge网络模式 -p 参数不受此影响，它能正常打开Host上的端口并映射到Container的对应Port。</p>
<h3 id="Docker存储卷"><a href="#Docker存储卷" class="headerlink" title="Docker存储卷"></a>Docker存储卷</h3><h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><ul>
<li>镜像是分层的，docker容器启动的时候会去加载镜像的只读层，然后在最上层添加一个读写层。</li>
<li>容器中的io都是针对读写层</li>
<li>如果要对只读层的内容进行修改或者删除，需要将只读层的内容copy到读写层，之后在读写层操作（tip：删除的话只是在读写层标记为删除）</li>
</ul>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>考虑我们做一个mysql的容器</p>
<ol>
<li>数据读写都在容器中的读写层，存储效率低。</li>
<li>数据会随着容器的删除而丢失</li>
</ol>
<p>此时就需要存储卷</p>
<ol>
<li><strong>“宿主机上”</strong>有个存储目录A，容器有个存储目录B，把这两个目录关联起来，A跟B的内容始终是同步的。那么A就是存储卷。</li>
<li>在容器删除的时候数据不会丢失</li>
<li>两个容器可以通过这种方式通信</li>
<li>1中“宿主机”并不准确，这个目录也可以是共享目录，比如nfs服务器上的目录，这样容器就不用局限在一个宿主机上。</li>
</ol>
<h4 id="两种类型"><a href="#两种类型" class="headerlink" title="两种类型"></a>两种类型</h4><ol>
<li>绑定挂载卷：宿主机的目录跟容器的目录都是run的时候指定的</li>
<li>docker管理卷：容器中的目录是run的时候指定的，宿主机目录由docker deamon自动指定</li>
</ol>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><ol>
<li>启动容器c1：关联宿主机目录/Users/wangzeqi/container/data 跟 容器目录/data</li>
<li>在/data目录下新建一个文件</li>
<li>删除容器c1，查看/Users/wangzeqi/container/data目录</li>
<li>启动容器c2，关联/Users/wangzeqi/container/data跟/data/temp，</li>
<li>查看/data/temp目录</li>
<li>查看容器信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1</span></span><br><span class="line">docker container run --name c1 --rm -it -v /Users/wangzeqi/container/data:/data busybox</span><br><span class="line"><span class="meta">#</span><span class="bash">2</span></span><br><span class="line">cd /data</span><br><span class="line">echo "hello" &gt;&gt; test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">3</span></span><br><span class="line">exit</span><br><span class="line">cd /Users/wangzeqi/container/data</span><br><span class="line">cat test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">4</span></span><br><span class="line">docker container run --name c2 --rm -it -v /Users/wangzeqi/container/data:/data/temp busybox</span><br><span class="line"><span class="meta">#</span><span class="bash">5</span></span><br><span class="line">cd data/temp/</span><br><span class="line">cat test.txt</span><br><span class="line"><span class="meta">#</span><span class="bash">6</span></span><br><span class="line">docker inspect c2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">可以看到如下信息</span></span><br><span class="line">"Mounts": [</span><br><span class="line">  &#123;</span><br><span class="line">    "Type": "bind", #存储卷类型</span><br><span class="line">    "Source": "/Users/wangzeqi/container/data", # 宿主机目录</span><br><span class="line">    "Destination": "/data/temp", # 容器目录</span><br><span class="line">    "Mode": "",</span><br><span class="line">    "RW": true,  </span><br><span class="line">    "Propagation": "rprivate"</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">6 或者</span></span><br><span class="line">docker inspect -f &#123;&#123;.Mounts&#125;&#125; c2</span><br><span class="line"><span class="meta">#</span><span class="bash">打印如下</span></span><br><span class="line">[&#123;bind  /Users/wangzeqi/container/data /data/temp   true rprivate&#125;]</span><br></pre></td></tr></table></figure>
<h4 id="tip-2"><a href="#tip-2" class="headerlink" title="tip"></a>tip</h4><ol>
<li><p>-v的目录如果不存在docker会自动创建</p>
</li>
<li><p>两个容器可以共享一个存储卷</p>
<ul>
<li>–volumes-from c1   复制容器c1的挂载关联规则</li>
</ul>
</li>
<li><p>两个容器可以共享一个网络空间（docker网络模式中的container模式）</p>
<ul>
<li>–network container:c1  加入c1的网络空间</li>
</ul>
</li>
<li><p>为了不用每次都指定容器的网络配置或者挂载配置，假如需要搭建nmt （nginx ，tomcat，mysql ）架构或者更加复杂的，可以</p>
<ul>
<li>创建一个基础架构容器，新建其他容器的时候从基础架构容器复制配置信息</li>
<li>或者使用容器编排工具（docker-compose），这个也支持创建基础架构容器</li>
<li>或者使用k8s编排</li>
</ul>
</li>
</ol>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>构建镜像的源码。镜像是分层的，dockerfile中每一条命令对应一层。</p>
<h4 id="工作逻辑"><a href="#工作逻辑" class="headerlink" title="工作逻辑"></a>工作逻辑</h4><ol>
<li><p>选定一个工作目录</p>
</li>
<li><p>工作目录下放Dockerfile文件</p>
</li>
<li><p>如果构建过程需要访问某个文件，那个这个文件必须在工作目录下</p>
</li>
<li><p>构建的时候工作目录下的文件都会打包到镜像。</p>
</li>
<li><p>.dockerignore文件中声明的文件不会打包到镜像</p>
</li>
</ol>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>先看一个实例，看注释即可（以下是在node容器中构建ant design vue项目的dockerfile）</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">13.11</span>.<span class="number">0</span></span><br><span class="line"><span class="comment"># install yarn</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install -y yarn</span></span><br><span class="line"><span class="bash"><span class="comment"># 指定工作目录</span></span></span><br><span class="line"><span class="bash">WORKDIR /app/lszy_admin_web</span></span><br><span class="line"><span class="bash"><span class="comment"># 安装依赖</span></span></span><br><span class="line"><span class="bash">COPY package.json yarn.lock ./</span></span><br><span class="line"><span class="bash">RUN yarn install</span></span><br><span class="line"><span class="bash"><span class="comment"># 将工程copy到工作目录</span></span></span><br><span class="line"><span class="bash">COPY ./ ./</span></span><br><span class="line"><span class="bash"><span class="comment"># 声明build的arg，测试环境：build:test；正式环境：build</span></span></span><br><span class="line"><span class="bash">ARG env</span></span><br><span class="line"><span class="bash"><span class="comment"># build</span></span></span><br><span class="line"><span class="bash">RUN yarn <span class="variable">$&#123;env&#125;</span></span></span><br><span class="line"><span class="bash"><span class="comment"># 将dist复制到存储卷</span></span></span><br><span class="line"><span class="bash">CMD cp -rf dist dist_copy</span></span><br></pre></td></tr></table></figure>
<h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h5><ol>
<li>定义基础镜像</li>
<li>默认情况下build命令会先在本地查看是否有该基础镜像，没有的话会去dockerHub拉取（如果设置了阿里的镜像加速，那么会从加速地址去拉取）或者也可以指定拉取的地址（registry）</li>
<li>格式：镜像仓库名:tag  或者 镜像仓库名@digest ， 第二种更加安全</li>
</ol>
<h5 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h5><p>废弃了，设置作者信息</p>
<h5 id="LABLE"><a href="#LABLE" class="headerlink" title="LABLE"></a>LABLE</h5><ol>
<li>替代maintainer</li>
<li>key-value形式</li>
<li>用来设置说明信息，类似注释</li>
</ol>
<h5 id="COPY-amp-amp-ADD"><a href="#COPY-amp-amp-ADD" class="headerlink" title="COPY &amp;&amp; ADD"></a>COPY &amp;&amp; ADD</h5><ol>
<li>从文件或者文件夹复制到镜像的指定目录</li>
<li>ADD可以复制url，COPY只能复制宿主机的内容</li>
<li>ADD复制tar文件时，会自动解压，copy不会自动解压</li>
<li>一条命令中源文件可以有多个，目标文件只能一个</li>
<li>复制文件夹的时候是复制文件夹下所有内容，文件夹本身不会复制过去</li>
<li>目标文件必须“/”结尾</li>
</ol>
<h5 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h5><ol>
<li>指定容器启动之后的工作目录</li>
<li>容器启动之后默认会进入该目录</li>
<li>DockerFile中WORKDIR声明工作路径之后，下面所有命令中涉及到镜像中的路径时都可以使用相对该工作目录的相对路径</li>
</ol>
<h5 id="ARG-amp-amp-ENV"><a href="#ARG-amp-amp-ENV" class="headerlink" title="ARG &amp;&amp; ENV"></a>ARG &amp;&amp; ENV</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wangzeqi@wangzeqideMacBook-Pro workspace % docker build -t <span class="string">"test"</span> .</span><br><span class="line">Sending build context to Docker daemon   5.12kB</span><br><span class="line">Step 1/3 : FROM busybox</span><br><span class="line"> ---&gt; 6d5fcfe5ff17</span><br><span class="line">Step 2/3 : WORKDIR	/</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 2630e64e0b23</span><br><span class="line">Removing intermediate container 2630e64e0b23</span><br><span class="line"> ---&gt; 70c2a25a7355</span><br><span class="line">Step 3/3 : RUN mkdir <span class="built_in">test</span> &amp;&amp;     <span class="built_in">cd</span> <span class="built_in">test</span> &amp;&amp;     <span class="built_in">echo</span> <span class="string">"hello"</span> &gt;&gt; test.txt</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 91496fb114ae</span><br><span class="line">Removing intermediate container 91496fb114ae</span><br><span class="line"> ---&gt; ddd723329232</span><br><span class="line">Successfully built ddd723329232</span><br><span class="line">Successfully tagged <span class="built_in">test</span>:latest</span><br></pre></td></tr></table></figure>
<ol>
<li><p>使用dockerfile构建镜像的过程如上，（注意每一层执行之后都有一个removing操作）每一层都会新建一个临时容器，在容器上运行该层的命令，运行完成之后删除容器</p>
</li>
<li><p>ARG用于定义镜像构建时传递的参数：在构建的过程中如果我们需要动态的传递参数，那么可以使用ARG命令指定形参，在build的时候传递实参</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Dockerfile</span></span><br><span class="line">ARG arg1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行构建</span></span><br><span class="line">docker build --build-arg arg1=build:test . -t node_lszy_admin_web</span><br></pre></td></tr></table></figure>
</li>
<li><p>ENV则是定义容器运行时传递的参数</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile</span></span><br><span class="line">ENV env1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器</span></span><br><span class="line">docker run --name <span class="built_in">test</span> --rm --env env1=build <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="CMD-amp-amp-RUN"><a href="#CMD-amp-amp-RUN" class="headerlink" title="CMD &amp;&amp; RUN"></a>CMD &amp;&amp; RUN</h5><pre><code>1. CMD 是在容器启动之后默认执行的命令，如果我们在docker run 之后加了命令，那么dockerfile中的的cmd将会被替换掉
 2. RUN 是在构建镜像是执行的命令
</code></pre><h5 id="VOLOMN"><a href="#VOLOMN" class="headerlink" title="VOLOMN"></a>VOLOMN</h5><ol>
<li>定义容器中的存储卷</li>
<li>run的时候不需要使用-v指定存储卷的位置</li>
<li>对应的宿主机上的挂载卷是docker自己指定的（对应存储卷的第二种类型）</li>
</ol>
<h5 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h5><ol>
<li>定义对外（宿主机）暴露的端口</li>
<li>run的时候直接-P（注意是大写P），docker会自动分配宿主机上的一个端口映射到容器暴露的端口</li>
<li>如果需要自己指定端口映射，运行时使用-p 3306:3306 （小写p）即可</li>
</ol>
<h4 id="tip-linux环境变量-arg跟env命令可能会用到"><a href="#tip-linux环境变量-arg跟env命令可能会用到" class="headerlink" title="tip:linux环境变量(arg跟env命令可能会用到)"></a>tip:linux环境变量(arg跟env命令可能会用到)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wangzeqi@wangzeqideMacBook-Pro dist % echo $&#123;name:-wzq&#125;</span><br><span class="line">wzq</span><br><span class="line">wangzeqi@wangzeqideMacBook-Pro dist % name=zpy</span><br><span class="line">wangzeqi@wangzeqideMacBook-Pro dist % echo $name</span><br><span class="line">zpy</span><br></pre></td></tr></table></figure>
<ul>
<li>“-wzq”如果name为空，那么name=wzq</li>
<li>“+wzq”如果name不为空，那么name=wzq</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol>
<li>一文教您如何通过 Docker 快速搭建各种测试环境(Mysql, Redis, Elasticsearch, MongoDB) <a href="https://juejin.im/post/5ce531b65188252d215ed8b7" target="_blank" rel="noopener">https://juejin.im/post/5ce531b65188252d215ed8b7</a> </li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/04/docker/" data-id="ckfotebqj002a20uqy5u9gst6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/03/05/spring-boot-log-配置/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          spring boot log 配置
        
      </div>
    </a>
  
  
    <a href="/2020/01/30/Kotlin/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Kotlin</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Andoird-反编译-讯飞/">Andoird 反编译 讯飞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Andoird-第三方登录/">Andoird 第三方登录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-tensorFlow/">Android  tensorFlow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-openCV/">Android openCV</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-recycleView-itemDecoration/">Android recycleView itemDecoration</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-recycleView-瀑布流/">Android recycleView 瀑布流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-recyclerView/">Android recyclerView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-sdk/">Android sdk</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-反编译/">Android 反编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-反编译-smali-讯飞/">Android 反编译 smali 讯飞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-基础/">Android 基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-安全/">Android 安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-微信小程序/">Android 微信小程序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-懒加载/">Android 懒加载</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-数据库/">Android 数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-架构/">Android 架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-自定义View/">Android 自定义View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-通信-eventBus/">Android 通信 eventBus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-音频/">Android 音频</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-gradle/">android gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-net/">android net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-permission/">android permission</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-ui/">android ui</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-内存优化/">android 内存优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-混合开发/">android 混合开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-源码/">android 源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android-音视频/">android 音视频</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/">jvm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kotlin/">kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode-dp/">leetcode dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode-dp-01背包/">leetcode dp 01背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode-stack/">leetcode stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/net/">net</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python-爬虫/">python 爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/server-test-api/">server test-api</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/svg-java/">svg java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后端-springBoot/">后端 springBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能优化/">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/混合开发-webView/">混合开发 webView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络，安全/">网络，安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/音视频/">音视频</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Andoird-反编译-讯飞/" style="font-size: 10px;">Andoird 反编译 讯飞</a> <a href="/tags/Andoird-第三方登录/" style="font-size: 10px;">Andoird 第三方登录</a> <a href="/tags/Android/" style="font-size: 12.5px;">Android</a> <a href="/tags/Android-tensorFlow/" style="font-size: 10px;">Android  tensorFlow</a> <a href="/tags/Android-openCV/" style="font-size: 10px;">Android openCV</a> <a href="/tags/Android-recycleView-itemDecoration/" style="font-size: 10px;">Android recycleView itemDecoration</a> <a href="/tags/Android-recycleView-瀑布流/" style="font-size: 10px;">Android recycleView 瀑布流</a> <a href="/tags/Android-recyclerView/" style="font-size: 10px;">Android recyclerView</a> <a href="/tags/Android-sdk/" style="font-size: 10px;">Android sdk</a> <a href="/tags/Android-反编译/" style="font-size: 10px;">Android 反编译</a> <a href="/tags/Android-反编译-smali-讯飞/" style="font-size: 10px;">Android 反编译 smali 讯飞</a> <a href="/tags/Android-基础/" style="font-size: 10px;">Android 基础</a> <a href="/tags/Android-安全/" style="font-size: 10px;">Android 安全</a> <a href="/tags/Android-微信小程序/" style="font-size: 10px;">Android 微信小程序</a> <a href="/tags/Android-懒加载/" style="font-size: 10px;">Android 懒加载</a> <a href="/tags/Android-数据库/" style="font-size: 10px;">Android 数据库</a> <a href="/tags/Android-架构/" style="font-size: 10px;">Android 架构</a> <a href="/tags/Android-自定义View/" style="font-size: 10px;">Android 自定义View</a> <a href="/tags/Android-通信-eventBus/" style="font-size: 10px;">Android 通信 eventBus</a> <a href="/tags/Android-音频/" style="font-size: 10px;">Android 音频</a> <a href="/tags/JVM/" style="font-size: 17.5px;">JVM</a> <a href="/tags/Kotlin/" style="font-size: 10px;">Kotlin</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/android-gradle/" style="font-size: 10px;">android gradle</a> <a href="/tags/android-net/" style="font-size: 10px;">android net</a> <a href="/tags/android-permission/" style="font-size: 10px;">android permission</a> <a href="/tags/android-ui/" style="font-size: 10px;">android ui</a> <a href="/tags/android-内存优化/" style="font-size: 10px;">android 内存优化</a> <a href="/tags/android-混合开发/" style="font-size: 10px;">android 混合开发</a> <a href="/tags/android-源码/" style="font-size: 10px;">android 源码</a> <a href="/tags/android-音视频/" style="font-size: 10px;">android 音视频</a> <a href="/tags/jvm/" style="font-size: 17.5px;">jvm</a> <a href="/tags/kotlin/" style="font-size: 10px;">kotlin</a> <a href="/tags/leetcode/" style="font-size: 12.5px;">leetcode</a> <a href="/tags/leetcode-dp/" style="font-size: 20px;">leetcode dp</a> <a href="/tags/leetcode-dp-01背包/" style="font-size: 10px;">leetcode dp 01背包</a> <a href="/tags/leetcode-stack/" style="font-size: 12.5px;">leetcode stack</a> <a href="/tags/net/" style="font-size: 10px;">net</a> <a href="/tags/python-爬虫/" style="font-size: 10px;">python 爬虫</a> <a href="/tags/server-test-api/" style="font-size: 10px;">server test-api</a> <a href="/tags/svg-java/" style="font-size: 10px;">svg java</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/后端-springBoot/" style="font-size: 10px;">后端 springBoot</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/数据结构/" style="font-size: 12.5px;">数据结构</a> <a href="/tags/混合开发-webView/" style="font-size: 10px;">混合开发 webView</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/网络，安全/" style="font-size: 10px;">网络，安全</a> <a href="/tags/设计模式/" style="font-size: 12.5px;">设计模式</a> <a href="/tags/音视频/" style="font-size: 15px;">音视频</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/09/kotlin-基础/">kotlin基础</a>
          </li>
        
          <li>
            <a href="/2020/03/19/后台开发/">后台开发</a>
          </li>
        
          <li>
            <a href="/2020/03/18/mysql添加索引解决速度问题/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/03/13/oss/">oss</a>
          </li>
        
          <li>
            <a href="/2020/03/10/python解析html/">python解析html</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 kb_jay<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>